# コード最適化ガイドライン（更新版）

## 最適化の目標

### 1. 保守性と明確さの向上
- コードの自己文書化（明確な命名規則の統一）
- 関数の単一責任化
- 理解しやすいコメントの追加
- 論理的なプロジェクト構造の整理

### 2. 学習と成長を促進する設計
- シンプルで理解しやすいパターンの採用
- 段階的に拡張可能なコード構造
- 再利用可能なコンポーネント設計

### 3. 安定性とエラー耐性
- ユーザー体験を守るエラーハンドリングの強化
- データ欠損時のデフォルト値・フォールバック対応
- デバッグを容易にするログ機能の改善

### 4. ユーザー体験の最適化
- 地図とマーカーの初期表示速度の改善
- モバイル操作性の向上
- 可能な範囲でのオフライン対応

### 5. 開発効率と環境設定の最適化
- 開発-テスト-デプロイサイクルの効率化
- 型安全性を活用したバグの早期発見
- 環境変数管理の最適化
  - ローカル環境では.envファイルから環境変数を読み取る
  - 本番環境ではGitHub Secretsから環境変数を自動取得
- 繰り返し作業の自動化

### 6. 既存ファイル間の連携強化
- プロジェクト内の既存機能・ユーティリティの活用最大化
- 定数・型・ヘルパー関数の二重実装防止
- コンポーネント間の一貫性確保

## 保持すべき機能や振る舞い

### 1. コア機能
- 位置情報に基づく地図表示
- 各POI（飲食店など）のマーカー表示
- マーカークラスタリング（多数の地点がある場合）
- 情報ウィンドウ/詳細表示機能
- 現在地表示と距離計算

### 2. ユーザー体験
- 初期ロード時の適切なズームレベルと中心位置
- モバイルでの拡大・縮小・移動のスムーズな動作
- 検索・フィルタリング機能
- エラー発生時のユーザーへの適切なフィードバック

### 3. データ管理
- Google Sheetsからのデータ取得と処理フロー
- データキャッシュ戦略
- データ更新メカニズム

### 4. セキュリティ要素
- API キーの保護メカニズム
- 実装済みのセキュリティヘッダー設定
- レート制限による保護

## 優先すべき設計原則

### 1. シンプルさ優先の原則
- KISS: 複雑なパターンより理解しやすいコード
- YAGNI: 必要になるまで機能を追加しない

### 2. コード品質の基本原則
- DRY: コードの重複を避ける
- 単一責任の原則 (SRP): 一つのコンポーネント・関数は一つの責任のみを持つ
- 明示的優先: 動作が予測可能なコード

### 3. React固有の原則
- 宣言的UIパターン: 命令型より宣言型のコーディング
- コンポーネント分割: 適切なサイズのコンポーネント
- 単方向データフロー: props down, events up の原則

### 4. TypeScript活用の原則
- 型安全の確保: any型の使用を最小限に
- インターフェースによる契約: データ構造を明確に定義
- 型推論の活用: 過度な型指定を避ける

### 5. 段階的成長の原則
- 反復的改善: 完璧を求めず継続的に改善
- リファクタリング習慣化: 小さな改善を継続的に行う
- 技術的負債の管理: 妥協点を明確にドキュメント化

### 6. 既存コードの再利用パターン
- 定数の一元管理: constants/ ディレクトリを最大限活用
- ユーティリティ関数: utils/ にある既存関数を優先的に活用
- 型定義の共有: types/ ディレクトリの型を一貫して使用
- カスタムフックの活用: hooks/ にある既存のフックを拡張・再利用
- アダプターパターン: adapters/ の抽象化レイヤーを活用
- サービス層の統一: services/ の既存実装との一貫性確保

## 技術的背景

- 言語/バージョン: TypeScript 5.8.2
- フロントエンド: React 19.0.0, Vite 6.2.2
- バックエンド: Express 4.21.2, Node.js v20以上
- 地図技術:
  - @googlemaps/js-api-loader
  - @googlemaps/markerclusterer
  - @react-google-maps/api
- API連携: Google Sheets API（PoI情報管理）
- セキュリティ: helmet, express-rate-limit, CSP設定
- 環境変数管理:
  - ローカル環境: .envファイル
  - 本番環境: GitHub Secrets（CI/CD連携）
- デプロイ環境: GitHub Pages（自動デプロイワークフロー設定済み）
  - デプロイ時にGitHub Secretsから環境変数を自動取得
- パフォーマンス要件: モバイル端末での表示速度を重視
- ターゲットブラウザ: 最新のChrome、Firefox、Safari、Edge
- デバイス対応: モバイルファースト、レスポンシブ対応必須

## コード分離の基本方針

- 既存ファイルに類似機能がある場合は、原則としてそれを拡張・修正する
- 新規ファイルは以下の場合にのみ作成する
  - 既存のファイルに類似機能が存在しない
  - 既存ファイルの修正よりも、分離した方が保守性や再利用性が明らかに向上する
  - 単一責任の原則に基づき、機能を適切に分離する必要がある
- プロジェクト内の既存のパターンとスタイルに一貫性を持たせることを最優先する
- 既存機能を再発明せず、最大限に活用する
- 不要なコードや機能は積極的に削除する

## 環境変数管理の指針

- 開発環境:
  - .envファイルを使用して環境変数を管理
  - .env.exampleを提供し、必要な変数を明示
  - 機密情報は.gitignoreに追加して保護

- 本番環境（GitHub Pages）:
  - GitHub Secretsに必要な環境変数を設定
  - GitHub Actionsワークフローで自動的に環境変数を取得・注入
  - ビルド時に環境変数を静的に埋め込む

## 評価ポイント

- コード再利用度: 既存のユーティリティ、定数、型、コンポーネントの活用度
- 重複排除: 既に実装されている機能の再実装を避ける
- コード一貫性: 既存コードのスタイルやパターンとの一貫性
- 環境設定の最適化: 開発/本番環境での環境変数管理の適切な実装
- 不要コードの削減: 使用されていない機能やコードの削除

## 成果物

最適化後のコードに加えて、以下の点について詳細な説明を提供してください：

- 行った変更の概要と理由
- 既存ファイルを修正した場合と新規ファイルを作成した場合、それぞれの判断理由
- 改善された点と、それがどのように最適化目標に貢献するか
- 環境変数管理の実装方法とその効果
- 削除したコードとその判断理由
- 将来の拡張や改善のための提案

# 不要なコードの具体例

## 1. 未使用のインポートと依存関係
- 使用されていないライブラリやコンポーネントのインポート
- package.jsonに記載されているが実際に使用していない依存パッケージ
- TypeScriptの型定義のみでインポートされ、実際のロジックでは使われていないモジュール

## 2. 環境変数関連の冗長なコード
- 使われなくなったAPIキーやエンドポイントの環境変数定義
- 複数の場所で重複して実装されている環境変数のロード処理
- 古いデプロイ方法向けの環境変数設定コード
- 開発環境専用だがプロダクションビルドに混入している環境変数

## 3. 開発・デバッグ用の残存コード
- 本番環境に残されたconsole.log文
- コメントアウトされたまま放置されているデバッグコード
- 開発中の試行錯誤が残ったままのコード片
- // TODOコメントのままになっている未完成機能

## 4. 不要になった機能や処理
- リファクタリングで置き換えられたが削除されていない古い実装
- 仕様変更により不要になったが残っている機能
- 開発中に作成した実験的機能で本番では使用しないもの
- 条件分岐で到達しない「デッドコード」

## 5. 重複実装されたユーティリティ
- プロジェクト内の複数の場所で似たような機能を実装している重複コード
- すでに既存ユーティリティで実装されている機能の再実装
- サードパーティライブラリで代替可能な自前実装

## 6. 非効率な環境分岐ロジック
例：
```typescript
// 冗長な環境変数チェックの例
if (process.env.NODE_ENV === 'development') {
  // 開発環境用コード
} else if (process.env.NODE_ENV === 'production') {
  // 本番環境用コード
} else if (process.env.NODE_ENV === 'test') {
  // テスト環境用コード
} else {
  // その他の環境（実際には存在しない）
}
```

## 7. CI/CD関連の古い設定
- 使われなくなったデプロイスクリプト
- 現在の環境構成に合わない古いワークフロー設定ファイル
- 複数の異なるCI/CDツール用の重複した環境変数設定

削除すべき不要なコードを特定するには、以下の方法が効果的です：
- 静的解析ツール（ESLint, TSLint）で未使用コードを検出
- 依存関係分析ツールでデッドコードを特定
- コードカバレッジレポートで実行されていないコードを確認
- 環境変数の使用状況を全コードベースで監査